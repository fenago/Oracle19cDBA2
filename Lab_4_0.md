# Lab_4_0: Managing Undo Data in Oracle 19c

### Objectives:
- Understand the role of DML (Data Manipulation Language) operations in generating undo data.
- Learn how to monitor and administer undo data effectively.
- Differentiate between undo data and redo data.
- Configure undo retention and guarantee retention to ensure data consistency.
- Enable and monitor temporary undo.

### Use Case:
In any Oracle Database environment, managing undo data is crucial for maintaining data consistency, supporting transaction rollback, and ensuring efficient space management. Understanding how to monitor and configure undo data helps database administrators maintain optimal performance and avoid common issues like space exhaustion or failed transactions.

This lab focuses on managing undo data in a multitenant architecture, specifically within the context of a Container Database (CDB) and multiple Pluggable Databases (PDBs). You will learn how to configure undo retention settings, guarantee undo retention, and enable temporary undo, all while understanding the differences between undo and redo data.

### Prerequisites:
- Access to an Oracle 19c Database environment with CDBLAB and PDBs (PDBLAB1, PDBLAB2, PDBLAB3).
- SQL*Plus or SQL Developer for executing SQL commands.

---

## Main Steps:

### 1. **Understanding DML and Undo Data Generation**

**Why:**
Undo data is generated whenever a DML operation (INSERT, UPDATE, DELETE) modifies the database. This data allows Oracle to roll back changes if a transaction fails or is canceled, and it also supports read consistency.

**Steps:**

1. **Connect to PDBLAB1 using SQL Developer or SQL*Plus:**
   ```sql
   CONNECT system@PDBLAB1
   ```

2. **Create a Sample Table (if it doesn't already exist):**
   ```sql
   CREATE TABLE employees (
       employee_id NUMBER PRIMARY KEY,
       first_name VARCHAR2(50),
       last_name VARCHAR2(50),
       department_id NUMBER,
       salary NUMBER(8,2)
   );
   ```

   **Explanation:**
   - This table will be used for generating undo data during DML operations.

3. **Insert Sample Data into the Table:**
   ```sql
   INSERT INTO employees (employee_id, first_name, last_name, department_id, salary)
   VALUES (1, 'John', 'Doe', 10, 50000);

   INSERT INTO employees (employee_id, first_name, last_name, department_id, salary)
   VALUES (2, 'Jane', 'Smith', 20, 60000);
   ```

4. **Perform a DML Operation:**
   ```sql
   UPDATE employees SET salary = salary * 1.1 WHERE department_id = 10;
   ```

5. **Query the undo information:**
   ```sql
   SELECT username, operation, sql_redo 
   FROM v$transaction 
   WHERE xidusn = (SELECT MAX(xidusn) FROM v$transaction);
   ```
   **Explanation:**
   - This query helps you see the undo data generated by the DML operation.

---

### 2. **Monitoring and Administering Undo Data**

**Why:**
Monitoring undo data is crucial for understanding how much space is being used and whether your undo tablespace is appropriately sized.

**Steps:**

1. **Connect to CDBLAB to Monitor Undo:**
   ```sql
   CONNECT sys@CDBLAB AS sysdba;
   ```

2. **View Undo Usage:**
   ```sql
   SELECT tablespace_name, SUM(bytes)/1024/1024 AS MB_USED
   FROM dba_undo_extents
   GROUP BY tablespace_name;
   ```

   **Explanation:**
   - This command provides a summary of undo space usage in the CDB and PDBs. Monitoring this helps ensure that the undo tablespace does not run out of space.

3. **Switch to a PDB (e.g., PDBLAB2) to Monitor Specific Undo Data:**
   ```sql
   ALTER SESSION SET CONTAINER = PDBLAB2;
   SELECT tablespace_name, SUM(bytes)/1024/1024 AS MB_USED
   FROM dba_undo_extents
   GROUP BY tablespace_name;
   ```

   **Explanation:**
   - This command shows undo data usage specifically within `PDBLAB2`, allowing you to manage space effectively in multitenant environments.

---

### 3. **Describing the Difference Between Undo Data and Redo Data**

**Why:**
Understanding the distinction between undo and redo data is fundamental for database recovery and performance tuning. Undo data allows for transaction rollback, while redo data supports recovery from failures.

**Explanation:**

- **Undo Data:**
  - Generated by DML operations to maintain the ability to rollback transactions.
  - Stored in the undo tablespace.
  - Used for read consistency and transaction rollback.

- **Redo Data:**
  - Logs all changes made to the database for recovery purposes.
  - Stored in redo log files.
  - Used during instance recovery to reapply changes after a failure.

**Steps:**

1. **View Redo Data Generation in CDBLAB:**
   ```sql
   SELECT a.group#, a.member, b.bytes/1024/1024 AS MB_USED
   FROM v$logfile a, v$log b
   WHERE a.group# = b.group#;
   ```

   **Explanation:**
   - This query helps you monitor redo log usage, which is essential for ensuring that the database can recover from failures.

---

### 4. **Configuring Undo Retention**

**Why:**
Configuring undo retention ensures that undo data is kept long enough to satisfy long-running queries and avoid "ORA-01555: snapshot too old" errors.

**Steps:**

1. **Set Undo Retention in PDBLAB3:**
   ```sql
   ALTER SYSTEM SET undo_retention = 1800 SCOPE=BOTH;
   ```

   **Explanation:**
   - This command sets the undo retention period to 30 minutes (1800 seconds) in `PDBLAB3`, ensuring that sufficient undo data is available for longer transactions.

---

### 5. **Guaranteeing Undo Retention**

**Why:**
In some cases, it is critical to guarantee that undo data is retained for the entire duration of a transaction, even if it means the transaction will fail due to insufficient space.

**Steps:**

1. **Create an Undo Tablespace (if it doesn't already exist):**
   ```sql
   CREATE UNDO TABLESPACE undotbs1 DATAFILE '/u01/app/oracle/oradata/undotbs01.dbf' SIZE 100M AUTOEXTEND ON;
   ```

   **Explanation:**
   - This creates an undo tablespace that will be used in the next step.

2. **Guarantee Undo Retention in the Undo Tablespace:**
   ```sql
   ALTER TABLESPACE undotbs1 RETENTION GUARANTEE;
   ```

   **Explanation:**
   - This command ensures that undo data is retained in `undotbs1`, preventing long-running transactions from failing due to a lack of consistent undo data.

---

### 6. **Enabling Temporary Undo**

**Why:**
Temporary undo allows for more efficient management of undo data for temporary objects, reducing the impact on regular undo tablespaces.

**Steps:**

1. **Enable Temporary Undo for the Entire Instance in CDBLAB:**
   ```sql
   ALTER SYSTEM SET temp_undo_enabled = true;
   ```

   **Explanation:**
   - This command enables temporary undo for the entire CDB instance, allowing for more efficient management of undo data.

2. **Monitor Temporary Undo Usage:**
   ```sql
   SELECT to_char(BEGIN_TIME,'dd/mm/yy hh24:mi:ss') "BEGIN TIME",
          txncount "TXNCNT", maxconcurrency, undoblkcnt, uscount, nospaceerrcnt
   FROM v$tempundostat;
   ```

   **Explanation:**
   - This query provides statistics on temporary undo usage, allowing you to monitor its effectiveness.

---

### Summary:
In this lab, you learned how to manage undo data in an Oracle 19c multitenant environment, including configuring undo retention, enabling temporary undo, and differentiating between undo and redo data. These skills are essential for maintaining data consistency, ensuring efficient space usage, and avoiding common errors such as "snapshot too old."

By following these steps, you can effectively manage undo data across your CDB and PDBs, ensuring your database runs smoothly even under heavy transaction loads.

---
### Addendum to Lab_4_0: Theoretical Challenge

#### **Challenge Use Case:**

**Scenario:**
You are the Database Administrator (DBA) for a large e-commerce platform that handles millions of transactions daily. The companyâ€™s Oracle 19c database environment includes a Container Database (CDBLAB) with multiple Pluggable Databases (PDBLAB1, PDBLAB2, PDBLAB3). 

The company recently launched a major marketing campaign, which has significantly increased the volume of transactions. This surge in activity has led to several issues, including:

1. **Frequent "snapshot too old" errors** affecting long-running queries in PDBLAB1.
2. **Temporary tablespace exhaustion** due to an increase in temporary data usage, impacting reporting and analytics tasks.
3. **Unstable transactions** in PDBLAB2 that occasionally fail due to insufficient undo data, leading to data inconsistency concerns.

Your challenge is to resolve these issues using the knowledge and techniques you learned in Lab_4_0.

---

### **Tasks:**

1. **Resolve the "Snapshot Too Old" Errors in PDBLAB1:**
   - The long-running queries are failing due to insufficient undo retention. To resolve this, you need to increase the undo retention period for PDBLAB1. This will ensure that the undo data required by these queries is not overwritten too quickly.
   - **Steps:**
     1. Connect to PDBLAB1.
     2. Configure the system to increase the undo retention period.

2. **Prevent Temporary Tablespace Exhaustion:**
   - The surge in temporary data usage is causing the temporary tablespace to become full, which is impacting your ability to run analytical queries. You need to enable a feature that will handle undo data for temporary objects more efficiently, thereby reducing the strain on the temporary tablespace.
   - **Steps:**
     1. Connect to CDBLAB.
     2. Enable the feature that optimizes undo management for temporary objects.

3. **Ensure Transaction Stability in PDBLAB2:**
   - Transactions in PDBLAB2 are failing due to insufficient undo data, which is critical for maintaining data consistency. To ensure these transactions have enough undo data, you need to guarantee that undo retention is prioritized, even if it means some transactions may fail due to space limitations.
   - **Steps:**
     1. Connect to PDBLAB2.
     2. Configure the undo tablespace to guarantee undo retention.

4. **Monitor the Database Environment:**
   - After making the above changes, it's crucial to monitor the database to ensure that the issues are resolved and that the system is performing optimally.
   - **Steps:**
     1. Use SQL queries to check the undo usage in PDBLAB1 and PDBLAB2.
     2. Monitor the temporary undo usage across the environment.
     3. Review redo log usage to ensure the system can recover from any unexpected failures.

---

### **Challenge Notes:**

- For each task, use the knowledge gained from Lab_4_0 to determine the appropriate SQL commands and configurations.
- Consider the impact of your changes on overall system performance and stability.
- Ensure that your solutions are aligned with best practices for Oracle Database management, particularly in high-transaction environments like e-commerce platforms.

---

This challenge is designed to test your understanding of undo management in Oracle 19c and your ability to apply these concepts in real-world scenarios. By following the steps outlined in the tasks, you should be able to resolve the issues faced by the e-commerce platform and ensure a stable, efficient database environment.
